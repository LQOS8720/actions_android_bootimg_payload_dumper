name: get_images_from_payload.bin
on:
  workflow_dispatch:
    inputs:
      UPLOAD_CONFIG:
        description: 'Upload Artifacts to Actions'
        required: true
        default: "false"
        type: boolean
      ROM_URL:
        description: 'ROM direct link (must contain payload.bin)'
        required: true
        default: "https://ultimateota.d.miui.com/OS2.0.206.0.VLFCNXM/diting-ota_full-OS2.0.206.0.VLFCNXM-user-15.0-ffb9d90a59.zip?t=1764465831&s=6cb61215b740756331758beb4f6a5b3a"
        type: string
      PARTITIONS:
        description: 'Partitions to extract (e.g., boot,vendor_dlkm,vendor_boot)'
        required: true
        default: "boot"
        type: string

env:
  TZ: Asia/Shanghai
  Payload_Dumper_Go_Url: https://github.com/ssut/payload-dumper-go/releases/download/1.2.2/payload-dumper-go_1.2.2_linux_amd64.tar.gz

jobs:
  make:
    runs-on: ubuntu-latest
    steps:
      - name: Clean Up Disk Space
        run: |
          docker images -q | xargs -r docker rmi || echo "No Docker images to remove."

      - name: Install jq (for tmpfiles.org JSON parsing)
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Create working directory
        run: mkdir -p "$HOME/work"

      - name: Download payload-dumper-go
        run: |
          cd "$HOME/work"
          wget --connect-timeout=10 --timeout=30 -O payload_dumper_go.tar.gz "$Payload_Dumper_Go_Url"

      - name: Extract payload-dumper-go
        run: |
          cd "$HOME/work"
          mkdir -p payload_dumper_go
          tar -xzf payload_dumper_go.tar.gz -C payload_dumper_go
          ls -l payload_dumper_go/

      - name: Verify and make executable
        run: |
          cd "$HOME/work"
          if [ ! -f payload_dumper_go/payload-dumper-go ]; then
            echo "‚ùå ERROR: payload-dumper-go not found after extraction!"
            exit 1
          fi
          chmod +x payload_dumper_go/payload-dumper-go
          echo "‚úÖ payload-dumper-go is ready."

      - name: Download ROM
        run: |
          cd "$HOME/work"
          echo "üì• Downloading ROM from: ${{ github.event.inputs.ROM_URL }}"
          wget --connect-timeout=10 --timeout=120 -O rom.zip "${{ github.event.inputs.ROM_URL }}"

      - name: Extract ROM and locate payload.bin
        run: |
          cd "$HOME/work"
          mkdir -p rom_extracted
          unzip -q rom.zip -d rom_extracted
          find rom_extracted -type f -name "payload.bin" -exec cp {} payload_dumper_go/ \;
          if [ ! -f payload_dumper_go/payload.bin ]; then
            echo "‚ùå ERROR: payload.bin not found in the ROM!"
            find rom_extracted -type f | head -n 30
            exit 1
          fi
          echo "‚úÖ payload.bin found and copied."

      - name: List partitions in payload.bin (debug)
        run: |
          cd "$HOME/work/payload_dumper_go"
          ./payload-dumper-go -l payload.bin

      - name: Extract specified partitions
        run: |
          cd "$HOME/work/payload_dumper_go"
          partitions="${{ github.event.inputs.PARTITIONS }}"
          args=()
          IFS=',' read -ra PARTS <<< "$partitions"
          for part in "${PARTS[@]}"; do
            part=$(echo "$part" | xargs)  # Trim whitespace
            if [ -n "$part" ]; then
              args+=("-p" "$part")
            fi
          done
          if [ ${#args[@]} -eq 0 ]; then
            echo "‚ùå No valid partitions specified."
            exit 1
          fi
          echo "üîß Extracting partitions: ${args[*]}"
          ./payload-dumper-go -o "$HOME/work/payload_dumper_go" "${args[@]}" payload.bin

      - name: List extracted images
        run: |
          cd "$HOME/work/payload_dumper_go"
          ls -lh *.img || { echo "‚ö†Ô∏è No .img files were extracted."; exit 1; }

      - name: Upload Artifact to GitHub
        if: ${{ github.event.inputs.UPLOAD_CONFIG == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: Extracted-Images
          path: ${{ runner.home }}/work/payload_dumper_go/*.img

      - name: Upload via Multiple Services (fallback chain)
        if: ${{ github.event.inputs.UPLOAD_CONFIG == 'false' }}
        run: |
          cd "$HOME/work"
          shopt -s nullglob
          img_files=(payload_dumper_go/*.img)
          
          if [ ${#img_files[@]} -eq 0 ]; then
            echo "‚ùå No .img files to upload."
            exit 1
          fi

          echo "üì§ Starting multi-service upload for ${#img_files[@]} file(s)..."

          upload_services=("transfer.sh" "0x0.st" "tmpfiles.org")

          for f in "${img_files[@]}"; do
            filename=$(basename "$f")
            echo "‚û°Ô∏è Processing: $filename"
            uploaded=false
            retry=0
            max_retries=3

            while [ $retry -lt $max_retries ] && [ "$uploaded" = false ]; do
              for service in "${upload_services[@]}"; do
                case "$service" in
                  "transfer.sh")
                    echo "  ‚Üí Trying transfer.sh..."
                    url=$(curl --connect-timeout 10 --max-time 60 --upload-file "$f" "https://transfer.sh/$filename" 2>/dev/null)
                    if [ $? -eq 0 ] && [ -n "$url" ]; then
                      echo "  ‚úÖ Success (transfer.sh): $url"
                      uploaded=true
                      break
                    fi
                    ;;

                  "0x0.st")
                    echo "  ‚Üí Trying 0x0.st..."
                    url=$(curl --connect-timeout 10 --max-time 60 --upload-file "$f" "https://0x0.st" 2>/dev/null)
                    if [ $? -eq 0 ] && [ -n "$url" ]; then
                      echo "  ‚úÖ Success (0x0.st): $url"
                      uploaded=true
                      break
                    fi
                    ;;

                  "tmpfiles.org")
                    echo "  ‚Üí Trying tmpfiles.org..."
                    response=$(curl --connect-timeout 10 --max-time 60 -F "file=@$f" "https://tmpfiles.org/api/v1/upload" 2>/dev/null)
                    if [ $? -eq 0 ]; then
                      url=$(echo "$response" | jq -r '.data.url // empty')
                      if [ -n "$url" ]; then
                        echo "  ‚úÖ Success (tmpfiles.org): $url"
                        uploaded=true
                        break
                      fi
                    fi
                    ;;
                esac
              done

              if [ "$uploaded" = false ]; then
                ((retry++))
                echo "  ‚ö†Ô∏è All services failed. Retry $retry/$max_retries..."
                sleep 3
              fi
            done

            if [ "$uploaded" = false ]; then
              echo "‚ùå Failed to upload $filename after $max_retries attempts."
              exit 1
            fi
          done

          echo "üéâ All files uploaded successfully!"
